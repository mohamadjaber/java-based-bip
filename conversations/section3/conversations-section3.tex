% *********************************************************************
% *********************************************************************

\section{Java Implementation}
\label{sec:java}
We have implemented in Java a model consisting of a set of classes that represents {\compmodel} model. Roughly speaking, we distinguish between two abstract classes \texttt{Behavior} and \texttt{Conversation}. Defining a new behavior, a developer has to do the following: 
\begin{itemize}
\item Create a new class that extends \texttt{Behavior} class. 
\item Create instance variables that represent locations, data variables and send ports assigned with data variables.
\item Create a constructor method that initialize location and create the set of transitions representing the behavior. 
\item Each transition consists of the source location, target location, guard, send port,  and action. By default, the guard is \texttt{true} and the action is empty.  
\end{itemize}
In the same way, we define a new conversation, except that it extends \texttt{Conversation} class and it also contain receive ports. Also, a transition of a conversation component consists of the source location, target location, set of receive ports, guard, upward action, send port, downward action. 

After defining behaviors and conversations we create the system by creating a new class that extends \texttt{Compound} class. In that class, we instantiate the defined behavior and conversation classes. Finally, we connect each receive port to its corresponding send port. 


We have implemented the semantic as proposed in Section \ref{sec:formal}. More precisely, we create a Java thread per behavior instance and another thread that plays as arbiter for selecting a top conversation component to be executing and down propagated. The execution flow is done as following: 
\begin{itemize}
\item Behavior components evaluates the guards of the their current outgoing transitions and notify the corresponding send ports accordingly.  
\item Notification of a send port implies the notification of all its corresponding receive ports. 
\item After a receive port has been notified of a specific conversation component, we evaluate its outgoing transitions whether all their receive ports have been notified. 
\item For those transitions, we evaluation their guards and we execute their up actions. 
\item Executing the up actions do not modify the actual data of the conversation component, but it creates a copy of those data. 
\item If the transition has a send port, we notify that port with an index that points to the copy values obtained by the corresponding up action. 
\item When all receive ports has been notified, the arbiter thread will be fired. Now, all behaviors are waiting. 
\item The arbiter selects a top enabled transition of a conversation component (i.e., without a send port). If such transition does not exists, then the system contains a deadlock. 
\item The arbiter execute the down action of that transition and update the original value w.r.t the index of the copy values of selected transition. Then, it recursively notifies the corresponding send port connected to the receive ports of that transition.  
\item If the send port belongs to a behavior component, we disable recursively all other send ports that belong to that component. 
\item We check for another top enabled transition of another conversation component. 
\item If there is no top enabled transition, the arbiter notifies behavior components to executing the action of the corresponding notified send ports. 
\end{itemize}

Note that, this implementation introduces some overhead due to the create of the copy of variables. Recall that, the guard of a given transition depends on the copy of the values of the variables attached the send ports connected to receive ports of that transition. A receive port has a direct access the variables of its corresponding send port. As each receive port has been notified by a send port with different indices. Thus, evaluating the guard requires to set the indices of the bottom conversation components that correspond to send ports connected to receive ports of that transition. That is, evaluation the guard uses the corresponding copy values. As the up propagation is done in parallel by the thread of the behavior component, we need to first lock those bottom conversation components to avoid other guards that depends on those components but with different indices. The complexity of this propagation is due to the non-determinism of conversation components. 


However, most of the examples consist of conversation components that are deterministic. That is, from any location, at maximum one of the outgoing transitions could be enabled. This can be satisfied if for all locations (1) there exist at maximum one outgoing transition; or (2) the guards of all outgoing transitions are mutually exclusive. In that case, we do not need neither creating copy of the variables nor setting indices or locking of bottom conversation components.
For this, we developed two implementations that assume non-deterministic and deterministic conversation components, respectively. Non-determinism of conversation components add more expressiveness but introduce some overhead.  


\begin{figure}
\scalebox{0.5}{\input{fig/pots.pdf_t}}
\end{figure}


% *********************************************************************
%\subsection{Request/Grant/Interrupt Formal Model}
%\label{sec:internal:model}
%\sidenote{Is this model necessary?}
%Formal model with ``send request'' and ``receive grants''.
%Transformation from conversations.
%Semantic equivalence and, in particular, preservation of deadlock-freedom
%(?).

